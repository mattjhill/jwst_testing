"""
This module contains the validation testing for the JWST Calibration
Pipeline.
"""

from astropy.io import fits
import numpy as np
import unittest
import pytest

dq_dict = {
'DO_NOT_USE' : 0,
'SATURATED' : 1,
'JUMP_DET' : 2,
'DROPOUT' : 3,
'RESERVED' : 4,     
'RESERVED' : 5,     
'RESERVED' : 6,     
'RESERVED' : 7,     
'UNRELIABLE_ERROR' : 8,
'NON_SCIENCE' : 9,
'DEAD' : 10,
'HOT' : 11,
'WARM' : 12,
'LOW_QE' : 13,
'RC' : 14,
'TELEGRAPH' : 15,
'NONLINEAR' : 16,
'BAD_REF_PIXEL' : 17,
'NO_FLAT_FIELD' : 18,
'NO_GAIN_VALUE' : 19,
'NO_LIN_CORR' : 20,
'NO_SAT_CHECK' : 21,
'UNRELIABLE_BIAS' : 22,
'UNRELIABLE_DARK' : 23,
'UNRELIABLE_SLOPE' : 24,
'UNRELIABLE_FLAT' : 25,
'OPEN' : 26,
'ADJ_OPEN' : 27,
'UNRELIABLE_RESET' : 28,
'MSA_FAILED_OPEN' : 29,
'OTHER_BAD_PIXEL' : 30,
}

def bitwise_propagate(refhdu, pixeldq):
    for row in refhdu['DQ_DEF'].data:
        try:
            # find which pixels have the bit set
            flagged = (np.bitwise_and(1, np.right_shift(refhdu['DQ'].data, row['BIT']))).astype(np.uint32)
            # shift them to the correct bit for PIXELDQ
            flagged = np.left_shift(flagged, dq_dict[row['NAME']])
            # propagate into the PIXELDQ extension
            pixeldq = np.bitwise_or(pixeldq, flagged)
        except KeyError:
            print("No DQ mnemonic "+row['NAME'])
    return pixeldq


@pytest.mark.dq_init
class TestDQInitStep:
    """
    The base class for testing the DQInitStep.
    """
    @pytest.fixture
    def refhdu(self, dq_init_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+dq_init_hdu[0].header['R_MASK'][7:]
        return fits.open(ref_file)

    def test_pixeldq_ext_exists(self, dq_init_hdu):
        """
        test_pixeldq_ext_exists

        Make sure the PIXELDQ extensions has been added to the HDUList.
        """
        assert("PIXELDQ" in dq_init_hdu)

    def test_pixeldq_propagation(self, dq_init_hdu, refhdu):
        """
        Make sure all DQ flags are propagated from the reference file to PIXELDQ
        """
        assert np.all(bitwise_propagate(refhdu, np.zeros_like(dq_init_hdu['PIXELDQ'].data)) == dq_init_hdu['PIXELDQ'].data)

    # def test_good_pixeldq_propagation(self, dq_init_hdu, refhdu):
    #     """
    #     make sure that the values in the reference mask are properly
    #     translated to values in PIXELDQ
    #     """

    #     pixeldq = dq_init_hdu['PIXELDQ'].data
    #     #find good/bad pixels
    #     # check that all good and pixels are preserved 
    #     good = np.where(refhdu['DQ'].data == 0)
    #     assert np.all(pixeldq[good] == 0)

    # def test_dead_pixeldq_propagtion(self, dq_init_hdu, refhdu):
    #     """
    #     make sure that the values in the reference mask are properly
    #     translated to values in PIXELDQ
    #     """

    #     pixeldq = dq_init_hdu['PIXELDQ'].data

    #     # check dead pixels
    #     dead = np.where(refhdu['DQ'].data == 3)
    #     assert np.all(pixeldq[dead] == 1025)

    # def test_hot_pixeldq_propagation(self, dq_init_hdu, refhdu):
    #     """
    #     make sure that the values in the reference mask are properly
    #     translated to values in PIXELDQ
    #     """

    #     pixeldq = dq_init_hdu['PIXELDQ'].data

    #     # #check hot pixels
    #     hot = np.where(refhdu['DQ'].data == 5)
    #     assert np.all(pixeldq[hot] == 2049)

    # def test_unreliable_slope_pixeldq_propagation(self, dq_init_hdu, refhdu):
    #     """
    #     make sure that the values in the reference mask are properly
    #     translated to values in PIXELDQ
    #     """

    #     pixeldq = dq_init_hdu['PIXELDQ'].data

    #     # #check unreliable slope
    #     urs = np.where(refhdu['DQ'].data == 9)
    #     assert np.all(pixeldq[urs] == 16777217)

    # def test_rc_pixeldq_propagation(self, dq_init_hdu, refhdu):
    #     """
    #     make sure that the values in the reference mask are properly
    #     translated to values in PIXELDQ
    #     """

    #     pixeldq = dq_init_hdu['PIXELDQ'].data

    #     # #check RC pixels
    #     rc = np.where(refhdu['DQ'].data == 17)
    #     assert np.all(pixeldq[rc] == 16385)

    def test_groupdq_ext_exists(self, dq_init_hdu):
        """
        Checks that the groupdq has been set.
        """
        # if using object from pipeline
        # assert(hasattr(self.dq_init., 'groupdq'))

        # if using fits file generated by strun
        assert("GROUPDQ" in dq_init_hdu)

    def test_groupdq_vals_all_zero(self, dq_init_hdu):
        """
        Checks that the groupdq extension 
        values are all zero after dq_init.
        """
        # if using object from pipeline
        # assert(np.all(self.dq_init.groupdq == 0))

        # if using fits file generated by strun
        assert(np.all(dq_init_hdu["GROUPDQ"].data == 0))


    def test_err_ext_exists(self, dq_init_hdu):
        """
        Check that all err extension values are all zero.
        """

        # if using object from pipeline
        # assert(hasattr(self.dq_init, 'err'))
        # if using fits file generated by strun
        assert("ERR" in dq_init_hdu)

    def test_err_vals_all_zero(self, dq_init_hdu):
        """
        Check that all err extension values are all zero.
        """

        # if using object from pipeline
        # assert(np.all(self.dq_init.pixeldq == 0))

        # if using fits file generated by strun
        assert(np.all(dq_init_hdu["ERR"].data == 0))

@pytest.mark.saturation
class TestSaturationStep:
    """
    The base class for testing the SaturationStep.
    """

    @pytest.fixture
    def refhdu(self, sat_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+sat_hdu[0].header['R_SATURA'][7:]
        return fits.open(ref_file)

    def test_groupdq_vals(self, sat_hdu, refhdu):
        """
        Check that saturated pixels are flagged properly
        """
        # TODO
        if 'DQ' in refhdu:
            flag = np.logical_and(sat_hdu['SCI'].data >= refhdu['SCI'].data, 
                refhdu['DQ'].data != 2)
        else: 
            flag = sat_hdu['SCI'].data > refhdu['SCI'].data

        expected_groupdq = np.zeros_like(sat_hdu['GROUPDQ'].data)
        expected_groupdq[flag] = 2
        
        #now make sure that pixels in groups after a flagged pixel are also flagged
        flag = (np.cumsum(expected_groupdq == 2, axis=1) > 0)
        expected_groupdq[flag] = 2 

        assert np.all(sat_hdu['GROUPDQ'].data == expected_groupdq)

    @pytest.mark.dq_init
    def test_saturation_pixeldq_propagation(self, sat_hdu, refhdu, dq_init_hdu):
        """
        check that proper Data Quality flags are added according to reference
        file.
        """
        assert np.all(bitwise_propagate(refhdu, dq_init_hdu['PIXELDQ'].data) == sat_hdu['PIXELDQ'].data)

@pytest.mark.ipc
class TestIPCStep:
    """
    The base class for testing the IPCStep.
    """

    @pytest.fixture
    def refhdu(self, ipc_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+sat_hdu[0].header['R_IPC'][7:]
        return fits.open(ref_file)

@pytest.mark.superbias
class TestSuperbiasStep:
    """
    The base class for testing the SuperbiasStep
    """

    @pytest.fixture
    def refhdu(self, superbias_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+superbias_hdu[0].header['R_SUPERB'][7:]
        return fits.open(ref_file)

    @pytest.mark.saturation
    def test_superbias_pixeldq_propagation(self, superbias_hdu, refhdu, sat_hdu):
        """
        check that proper Data Quality flags are added according to reference
        file.
        """
        assert np.all(bitwise_propagate(refhdu, sat_hdu['PIXELDQ'].data) == superbias_hdu['PIXELDQ'].data)

@pytest.mark.refpix
class TestRefpixStep:
    """
    The base class for testing the RefpixStep
    """
    @pytest.fixture
    def refhdu(self, refpix_hdu):
        if 'R_REFPIX' in refpix_hdu[0].header:
            CRDS = '/grp/crds/cache/references/jwst/'
            ref_file = CRDS+superbias_hdu[0].header['R_REFPIX'][7:]
            return fits.open(ref_file)

@pytest.mark.reset
class TestResetStep:
    """
    The base class for testing the ResetStep
    """
    @pytest.fixture
    def refhdu(self, reset_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+reset_hdu[0].header['R_RESET'][7:]
        return fits.open(ref_file)

    def test_reset_correction(self, refpix_hdu, refhdu, reset_hdu):
        nints, ngroups, nx, ny = reset_hdu['SCI'].data.shape
        print(nints, ngroups)
        results = []
        for i in range(nints):
            for g in range(ngroups-1):
                if i >= refhdu['SCI'].data.shape[0]:
                    results.append(np.allclose(refpix_hdu['SCI'].data[i,g,:,:] - refhdu['SCI'].data[-1,g,:,:], reset_hdu['SCI'].data[i,g,:,:]))
                elif g >= refhdu['SCI'].data.shape[1]:
                    results.append(np.allclose(refpix_hdu['SCI'].data[i,g,:,:], reset_hdu['SCI'].data[i,g,:,:]))
                else:
                    results.append(np.allclose(refpix_hdu['SCI'].data[i,g,:,:] - refhdu['SCI'].data[i,g,:,:], reset_hdu['SCI'].data[i,g,:,:]))
        assert np.all(results)


    def test_reset_pixeldq_propagation(self, refpix_hdu, refhdu, reset_hdu):
        assert np.all(bitwise_propagate(refhdu, refpix_hdu['PIXELDQ'].data) == reset_hdu['PIXELDQ'].data)


class TestLastframeStep:
    """
    The base class for testing the Lastframe Step
    """
    @pytest.fixture
    def refhdu(self, lastframe_hdu):
        if lastframe_hdu[0].header['INSTRUME'] != 'MIRI':
            pytest.skip()

        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+lastframe_hdu[0].header['R_LASTFR'][7:]
        return fits.open(ref_file)

    def test_lastframe_correction(self, reset_hdu, refhdu, lastframe_hdu):
        """
        The Lastframe step should subtract the reference values from the last frame of 
        each integration.  Only for MIRI data.
        """
        expected = reset_hdu['SCI'].data
        expected[:,-1,:,:] -= refhdu['SCI'].data
        assert np.allclose(expected, lastframe_hdu['SCI'].data)

@pytest.mark.linearity
class TestLinearityStep:
    """
    The base class for testing the LinearityStep
    """

    @pytest.fixture(scope="class")
    def refhdu(self, linearity_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+linearity_hdu[0].header['R_LINEAR'][7:]
        return fits.open(ref_file)

    def test_linearity_correction(self, linearity_hdu, refhdu, lastframe_hdu):
        """
        Check that the linearity correction is properly applied to all relevant pixels.
        """

        # ignore pixels which are saturated (GROUPDQ = 2) or NO_LIN_CORR (DQ = 2)
        corrected = np.logical_and(lastframe_hdu['GROUPDQ'].data != 2, refhdu['DQ'].data != 2)
        
        linearity_applied = np.allclose(
            np.polyval(refhdu['COEFFS'].data[::-1], lastframe_hdu['SCI'].data)[corrected], 
            linearity_hdu['SCI'].data[corrected])

        linearity_ignored = np.allclose(lastframe_hdu['SCI'].data[~corrected], 
            linearity_hdu['SCI'].data[~corrected])

        # make sure that the values linearity correction is properly applied to relevant pixels
        # and ignored elsewhere
        assert linearity_applied and linearity_ignored

    @pytest.fixture(scope="class")
    def percent_rms(self, linearity_hdu):
        """
        Calculate the percent rms after fitting a line to the linearity corrected
        ramps.
        """
        nints, ngroups, nx, ny = linearity_hdu['SCI'].data.shape
        pixeldq = linearity_hdu['PIXELDQ'].data
        rms = np.zeros((nints, nx, ny))
        for i in range(nints):
            data = linearity_hdu['SCI'].data[i]
            groupdq = linearity_hdu['GROUPDQ'].data[i]
            groups = np.arange(data.shape[0])
            for (x,y), val in np.ndenumerate(data[0]):
                if x % 500 == 0 and y == 0:
                    print(x,y)
                usable = groupdq[:,x,y] == 0
                residuals = np.zeros(groupdq[0].shape)
                if usable.sum() > 4 and pixeldq[x,y] == 0: # make sure there are atleast 4 unsaturated groups
                    p = np.polyfit(groups[usable], data[:,x,y][usable], 1)
                    res = np.polyval(p, groups[usable]) - data[:,x,y][usable]
                    #residuals[usable] = res
                    rms[i, x,y] = np.std(res) / np.max(data[:,x,y][usable]) * 100

        return rms

    def test_linearity_median_residuals_rms_lt_1percent(self, percent_rms):
        """
        Check that after the linearity correction the ramps agree with a linear fit to within
        some threshold (1% ?)
        """
        good = percent_rms != 0
        assert np.median(percent_rms[good]) < 1.

    def test_linearity_99percent_of_residuals_rms_lt1percent(self, percent_rms):
        """
        Check that more than 99% of pixels have rms residuals < 1%
        """
        good = np.logical_and(percent_rms != 0, ~np.isnan(percent_rms))
        assert float(np.sum(percent_rms[good] < 1.))/len(percent_rms[good]) < 99.

    @pytest.mark.lastframe
    def test_linearity_pixeldq_propagation(self, linearity_hdu, refhdu, lastframe_hdu):
        """
        check that proper Data Quality flags are added according to reference
        file.
        """
        try:
            assert np.all(bitwise_propagate(refhdu, lastframe_hdu['PIXELDQ'].data) == linearity_hdu['PIXELDQ'].data)
        except KeyError:
            assert np.all(refhdu['DQ'].data == 0)

@pytest.mark.dark_current
class TestDarkCurrentStep:
    """
    The base class for testing the DarkCurrentStep
    """

    @pytest.fixture
    def refhdu(self, dark_current_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+dark_current_hdu[0].header['R_DARK'][7:]
        return fits.open(ref_file)

    def test_dark_current_pixeldq_propagation(self, dark_current_hdu, refhdu, linearity_hdu):
        """
        check that proper Data quality flags are added according to the reference file.
        """
        assert np.all(bitwise_propagate(refhdu, linearity_hdu['PIXELDQ'].data) == dark_current_hdu['PIXELDQ'].data)


##############################################################################
################################# 2B steps ###################################
##############################################################################

@pytest.mark.assign_wcs
class TestAssignWCSStep:
    """
    The base class for testing the assign_wcs step
    """

@pytest.mark.flat_field
class TestFlatFieldStep:
    """
    The base class for testing the flat_field step
    """

    @pytest.fixture
    def refhdu(self, flat_field_hdu):
        CRDS = '/grp/crds/cache/references/jwst/'
        ref_file = CRDS+flat_field_hdu[0].header['R_FLAT'][7:]
        return fits.open(ref_file)

    def test_flat_field_correction(self, flat_field_hdu, refhdu, assign_wcs_hdu):
        """
        Check that the flat field correction is applied properly to the input file.
        The flat correction should divide the input data by the matching pixel values in the 
        reference file unless they are flagged in reference file DQ extension.
        """
        correct = refhdu['DQ'].data == 0
        expected_flat = assign_wcs_hdu['SCI'].data
        expected_flat[correct] = assign_wcs_hdu['SCI'].data[correct]/refhdu['SCI'].data[correct]
        assert np.all(flat_field_hdu['SCI'].data  == expected_flat)

    @pytest.mark.xfail
    def test_flat_field_dq(self, flat_field_hdu, refhdu, assign_wcs_hdu):
        """
        check that proper Data quality flags are added according to the reference file.

        NOTE: This fails in build 6.
        """
        assert np.all(bitwise_propagate(refhdu, assign_wcs_hdu['DQ'].data) == flat_field_hdu['DQ'].data)


@pytest.mark.persistence
class TestPersistenceStep:
    """
    The base class for testing the persistence step
    """

@pytest.mark.emission
class TestEmissionStep:
    """
    The base class for testing the emission step
    """

@pytest.mark.photom
class TestPhotomStep:
    """
    The base class for testing the photom step
    """
